<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PVE Round-Based Battle</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Courier New', monospace;
            background: #1a1a1a;
            color: #e0e0e0;
            overflow: hidden;
        }
        
        .container {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        h1 {
            text-align: center;
            padding: 15px;
            color: #fff;
            font-size: 20px;
            background: #252525;
            border-bottom: 2px solid #444;
        }
        
        /* Setup Screen */
        .setup-screen {
            padding: 30px;
            overflow-y: auto;
        }
        
        .character-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .character-card {
            background: #2a2a2a;
            border: 2px solid #444;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .character-card:hover {
            border-color: #666;
            transform: translateY(-2px);
        }
        
        .character-card.selected {
            border-color: #4a9eff;
            background: #2a3a4a;
        }
        
        .character-card h3 {
            margin-bottom: 10px;
            color: #4a9eff;
        }
        
        .stat-line {
            font-size: 12px;
            margin: 3px 0;
            color: #aaa;
        }
        
        .skill-item {
            font-size: 11px;
            margin: 5px 0;
            padding: 5px;
            background: #1a1a1a;
            border-left: 2px solid #555;
            padding-left: 8px;
        }
        
        .passive-select {
            margin-top: 20px;
            padding: 15px;
            background: #2a2a2a;
            border: 2px solid #444;
        }
        
        .passive-option {
            padding: 10px;
            margin: 5px 0;
            background: #1a1a1a;
            border: 1px solid #444;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .passive-option:hover {
            border-color: #666;
        }
        
        .passive-option.selected {
            border-color: #4a9eff;
            background: #2a3a4a;
        }
        
        .faction-select {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        
        .faction-btn {
            padding: 15px 30px;
            background: #2a2a2a;
            border: 2px solid #444;
            color: #e0e0e0;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            transition: all 0.2s;
        }
        
        .faction-btn:hover {
            border-color: #666;
        }
        
        .faction-btn.selected {
            border-color: #4a9eff;
            background: #2a3a4a;
        }
        
        .start-btn {
            display: block;
            margin: 20px auto;
            padding: 15px 50px;
            background: #4a9eff;
            border: none;
            color: #fff;
            font-size: 16px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            transition: all 0.2s;
        }
        
        .start-btn:hover {
            background: #3a8eef;
        }
        
        .start-btn:disabled {
            background: #444;
            cursor: not-allowed;
        }
        
        /* Game Screen - Split Layout */
        .game-screen {
            display: none;
            flex: 1;
            overflow: hidden;
        }
        
        .game-container {
            display: flex;
            flex-direction: column;
            height: 100%;
        }
        
        /* Upper Half - Opponents */
        .opponents-area {
            flex: 1;
            background: #1f1f1f;
            border-bottom: 3px solid #4a9eff;
            overflow-y: auto;
            padding: 15px;
        }
        
        .opponents-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
        }
        
        /* Lower Half - Player */
        .player-area {
            flex: 1;
            background: #252525;
            display: flex;
            flex-direction: column;
        }
        
        .player-info {
            padding: 15px;
            border-bottom: 2px solid #444;
        }
        
        .player-actions {
            flex: 1;
            display: flex;
            overflow: hidden;
        }
        
        .player-skills {
            flex: 2;
            padding: 15px;
            overflow-y: auto;
            border-right: 2px solid #444;
        }
        
        .combat-log-area {
            flex: 1;
            padding: 15px;
            overflow-y: auto;
            background: #1a1a1a;
        }
        
        /* Character Panel */
        .char-panel {
            background: #2a2a2a;
            border: 2px solid #444;
            padding: 12px;
            position: relative;
        }
        
        .char-panel.active-turn {
            border-color: #ffd700;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
        }
        
        .char-panel.dead {
            opacity: 0.5;
            border-color: #666;
        }
        
        .char-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .char-name {
            font-weight: bold;
            color: #4a9eff;
            font-size: 14px;
        }
        
        .faction-badge {
            font-size: 10px;
            padding: 2px 6px;
            background: #1a1a1a;
            border: 1px solid #555;
        }
        
        .stat-bars {
            margin: 10px 0;
        }
        
        .stat-bar {
            margin: 5px 0;
        }
        
        .stat-bar-label {
            font-size: 10px;
            color: #888;
            margin-bottom: 2px;
        }
        
        .stat-bar-container {
            background: #1a1a1a;
            height: 16px;
            border: 1px solid #444;
            position: relative;
            display: flex;
            align-items: center;
        }
        
        .stat-bar-fill {
            height: 100%;
            transition: width 0.3s;
        }
        
        .stat-bar-fill.hp {
            background: #51cf66;
        }
        
        .stat-bar-fill.mp {
            background: #4a9eff;
        }
        
        .stat-bar-fill.shield {
            background: #ffd700;
        }
        
        .stat-bar-text {
            position: absolute;
            left: 0;
            right: 0;
            text-align: center;
            font-size: 10px;
            font-weight: bold;
            color: #fff;
            text-shadow: 1px 1px 2px #000;
            z-index: 1;
        }
        
        .char-details {
            font-size: 11px;
            margin-top: 10px;
        }
        
        .detail-row {
            display: flex;
            justify-content: space-between;
            margin: 3px 0;
            padding: 3px 5px;
            background: #1a1a1a;
        }
        
        .cards-row {
            margin-top: 8px;
            padding: 5px;
            background: #1a1a1a;
            font-size: 10px;
        }
        
        .card-chip {
            display: inline-block;
            padding: 2px 6px;
            margin: 2px;
            background: #2a2a2a;
            border: 1px solid #555;
            font-size: 9px;
        }
        
        .spells-row {
            margin-top: 5px;
            padding: 5px;
            background: #1a1a1a;
            font-size: 10px;
            color: #a78bfa;
        }
        
        .spell-chip {
            display: inline-block;
            padding: 2px 6px;
            margin: 2px;
            background: #2a2a2a;
            border: 1px solid #7c3aed;
            font-size: 9px;
            cursor: help;
        }
        
        /* Skills Display */
        .phase-indicator {
            text-align: center;
            padding: 8px;
            background: #1a1a1a;
            margin-bottom: 10px;
            font-weight: bold;
            color: #4a9eff;
            font-size: 12px;
        }
        
        .skills-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 10px;
        }
        
        .skill-card {
            background: #1a1a1a;
            border: 2px solid #444;
            padding: 10px;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }
        
        .skill-card:hover:not(.disabled) {
            border-color: #4a9eff;
            transform: translateY(-2px);
        }
        
        .skill-card.disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        
        .skill-card-name {
            font-weight: bold;
            color: #4a9eff;
            font-size: 12px;
            margin-bottom: 5px;
        }
        
        .skill-card-stats {
            font-size: 10px;
            color: #888;
        }
        
        .skill-card-stat {
            display: inline-block;
            margin-right: 8px;
        }
        
        .tooltip {
            display: none;
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: #2a2a2a;
            border: 2px solid #4a9eff;
            padding: 10px;
            min-width: 200px;
            z-index: 1000;
            font-size: 11px;
            margin-bottom: 5px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.5);
        }
        
        .skill-card:hover .tooltip {
            display: block;
        }
        
        /* RPS Modal */
        .rps-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }
        
        .rps-content {
            background: #252525;
            border: 3px solid #4a9eff;
            padding: 40px;
            text-align: center;
            max-width: 600px;
        }
        
        .rps-content h2 {
            color: #4a9eff;
            margin-bottom: 20px;
            font-size: 24px;
        }
        
        .rps-buttons {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 30px;
        }
        
        .rps-btn {
            padding: 30px 50px;
            background: #1a1a1a;
            border: 3px solid #444;
            color: #e0e0e0;
            cursor: pointer;
            font-size: 18px;
            font-family: 'Courier New', monospace;
            transition: all 0.2s;
            font-weight: bold;
        }
        
        .rps-btn:hover {
            border-color: #4a9eff;
            transform: scale(1.05);
        }
        
        .rps-waiting {
            margin-top: 20px;
            color: #ffd700;
            font-size: 14px;
        }
        
        .rps-results {
            margin: 20px 0;
            padding: 15px;
            background: #1a1a1a;
            border: 2px solid #444;
        }
        
        .rps-result-item {
            display: flex;
            justify-content: space-between;
            padding: 8px;
            margin: 5px 0;
            background: #252525;
            border-left: 3px solid #4a9eff;
        }
        
        .rps-result-item.eliminated {
            opacity: 0.5;
            border-left-color: #666;
        }
        
        /* Target Selection */
        .target-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }
        
        .target-content {
            background: #252525;
            border: 3px solid #4a9eff;
            padding: 30px;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .target-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .target-card {
            background: #1a1a1a;
            border: 2px solid #444;
            padding: 15px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .target-card:hover {
            border-color: #4a9eff;
        }
        
        .target-card.selected {
            border-color: #4a9eff;
            background: #2a3a4a;
        }
        
        .confirm-btn {
            display: block;
            margin: 20px auto 0;
            padding: 15px 40px;
            background: #4a9eff;
            border: none;
            color: #fff;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 16px;
        }
        
        .confirm-btn:hover {
            background: #3a8eef;
        }
        
        /* Combat Log */
        .log-entry {
            margin: 5px 0;
            padding: 5px 8px;
            border-left: 2px solid #555;
            font-size: 11px;
        }
        
        .log-rps { color: #ffa500; border-left-color: #ffa500; }
        .log-damage { color: #ff6b6b; border-left-color: #ff6b6b; }
        .log-heal { color: #51cf66; border-left-color: #51cf66; }
        .log-spell { color: #a78bfa; border-left-color: #a78bfa; }
        .log-system { color: #4a9eff; border-left-color: #4a9eff; }
        
        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>PVE ROUND-BASED BATTLE</h1>
        
        <!-- Setup Screen -->
        <div class="setup-screen" id="setupScreen">
            <h2 style="margin-bottom: 20px;">SELECT YOUR CHARACTER</h2>
            <div class="character-grid" id="characterGrid"></div>
            
            <div class="passive-select hidden" id="passiveSelect">
                <h3 style="margin-bottom: 15px;">SELECT PASSIVE SKILL</h3>
                <div id="passiveOptions"></div>
            </div>
            
            <div class="faction-select">
                <h3 style="width: 100%; text-align: center; margin-bottom: 15px;">SELECT FACTION</h3>
                <button class="faction-btn" data-faction="1">FACTION 1</button>
                <button class="faction-btn" data-faction="2">FACTION 2</button>
            </div>
            
            <button class="start-btn" id="startBtn" disabled>START GAME</button>
        </div>
        
        <!-- Game Screen -->
        <div class="game-screen" id="gameScreen">
            <div class="game-container">
                <!-- Upper Half: Opponents -->
                <div class="opponents-area">
                    <div class="opponents-grid" id="opponentsGrid"></div>
                </div>
                
                <!-- Lower Half: Player -->
                <div class="player-area">
                    <div class="player-info" id="playerInfo"></div>
                    <div class="player-actions">
                        <div class="player-skills">
                            <div class="phase-indicator" id="phaseIndicator">Waiting...</div>
                            <div class="skills-grid" id="skillsGrid"></div>
                        </div>
                        <div class="combat-log-area" id="combatLog"></div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- RPS Modal -->
        <div class="rps-modal hidden" id="rpsModal">
            <div class="rps-content">
                <h2>ROCK PAPER SCISSORS</h2>
                <p style="color: #888;">Make your choice!</p>
                <div class="rps-buttons">
                    <button class="rps-btn" data-choice="rock">ROCK</button>
                    <button class="rps-btn" data-choice="paper">PAPER</button>
                    <button class="rps-btn" data-choice="scissors">SCISSORS</button>
                </div>
                <div class="rps-waiting hidden" id="rpsWaiting">Waiting for other players...</div>
                <div class="rps-results hidden" id="rpsResults"></div>
            </div>
        </div>
        
        <!-- Target Selection Modal -->
        <div class="target-modal hidden" id="targetModal">
            <div class="target-content">
                <h2 style="margin-bottom: 20px; color: #4a9eff;">SELECT TARGET(S)</h2>
                <div class="target-grid" id="targetGrid"></div>
                <button class="confirm-btn" id="confirmTargetBtn">CONFIRM</button>
            </div>
        </div>
    </div>
    
    <script>
        // Game Data
        const CHARACTERS = {
            'YRYR_00': {
                code: 'YRYR_00',
                name: 'Akari',
                maxHP: 5,
                maxMP: 5,
                maxShield: 5,
                valueTag: 'order',
                groupTags: ['warrior'],
                description: 'Balanced fighter with evasion support',
                activeSkills: [
                    {
                        code: 'YRYR_00_01',
                        name: 'Double Strike',
                        phase: 'execution',
                        cooldown: 3,
                        mpCost: 0,
                        targetCount: 2,
                        targetType: 'enemy',
                        description: 'Deal 2 physical damage to up to 2 targets',
                        effect: (targets, user) => ({ type: 'physical', damage: 2, targets })
                    },
                    {
                        code: 'YRYR_00_02',
                        name: 'Heavy Blow',
                        phase: 'execution',
                        cooldown: 1,
                        mpCost: 0,
                        targetCount: 1,
                        targetType: 'enemy',
                        description: 'Deal 4 physical damage to 1 target',
                        effect: (targets, user) => ({ type: 'physical', damage: 4, targets })
                    },
                    {
                        code: 'YRYR_00_03',
                        name: 'Evasion Ward',
                        phase: 'execution',
                        cooldown: 3,
                        mpCost: 0,
                        targetCount: 1,
                        targetType: 'any',
                        description: 'Target evades next attack',
                        effect: (targets, user) => ({ type: 'spell', spell: { type: 'evade_next', positive: true }, targets })
                    },
                    {
                        code: 'YRYR_00_04',
                        name: 'Heal',
                        phase: 'execution',
                        cooldown: 2,
                        mpCost: 0,
                        targetCount: 1,
                        targetType: 'any',
                        description: 'Recover 5 HP',
                        effect: (targets, user) => ({ type: 'heal', amount: 5, targets })
                    }
                ],
                passiveSkills: [
                    {
                        code: 'YRYR_00_P1',
                        name: 'MP Drain',
                        description: 'Each non-evaded attack deals -1 MP to target'
                    },
                    {
                        code: 'YRYR_00_P2',
                        name: 'Crowd Immunity',
                        description: 'If alive players > 3, cannot be selected by AOE'
                    }
                ]
            },
            'TEST_01': {
                code: 'TEST_01',
                name: 'Blaze',
                maxHP: 5,
                maxMP: 5,
                maxShield: 5,
                valueTag: 'liberty',
                groupTags: ['mage'],
                description: 'Fire mage with strong AOE',
                activeSkills: [
                    {
                        code: 'TEST_01_01',
                        name: 'Fireball',
                        phase: 'execution',
                        cooldown: 1,
                        mpCost: 1,
                        targetCount: 1,
                        targetType: 'enemy',
                        description: 'Deal 3 magical damage',
                        effect: (targets, user) => ({ type: 'magical', damage: 3, targets })
                    },
                    {
                        code: 'TEST_01_02',
                        name: 'Fire Nova',
                        phase: 'execution',
                        cooldown: 3,
                        mpCost: 2,
                        targetCount: 'all',
                        targetType: 'enemy',
                        description: 'Deal 2 magical damage to all enemies',
                        effect: (targets, user) => ({ type: 'magical', damage: 2, targets })
                    },
                    {
                        code: 'TEST_01_03',
                        name: 'Mana Shield',
                        phase: 'pre-execution',
                        cooldown: 2,
                        mpCost: 1,
                        targetCount: 0,
                        targetType: 'self',
                        description: 'Gain 3 shield',
                        effect: (targets, user) => ({ type: 'shield', amount: 3, targets: [user] })
                    }
                ],
                passiveSkills: [
                    {
                        code: 'TEST_01_P1',
                        name: 'Burn',
                        description: 'Magical attacks add burn spell (1 damage next turn)'
                    }
                ]
            },
            'TEST_02': {
                code: 'TEST_02',
                name: 'Guardian',
                maxHP: 6,
                maxMP: 4,
                maxShield: 6,
                valueTag: 'equality',
                groupTags: ['tank'],
                description: 'High defense tank',
                activeSkills: [
                    {
                        code: 'TEST_02_01',
                        name: 'Shield Slam',
                        phase: 'execution',
                        cooldown: 1,
                        mpCost: 0,
                        targetCount: 1,
                        targetType: 'enemy',
                        description: 'Deal 2 physical damage',
                        effect: (targets, user) => ({ type: 'physical', damage: 2, targets })
                    },
                    {
                        code: 'TEST_02_02',
                        name: 'Fortify',
                        phase: 'pre-execution',
                        cooldown: 2,
                        mpCost: 1,
                        targetCount: 0,
                        targetType: 'self',
                        description: 'Gain 4 shield',
                        effect: (targets, user) => ({ type: 'shield', amount: 4, targets: [user] })
                    },
                    {
                        code: 'TEST_02_03',
                        name: 'Taunt',
                        phase: 'execution',
                        cooldown: 3,
                        mpCost: 0,
                        targetCount: 1,
                        targetType: 'enemy',
                        description: 'Force target to attack you',
                        effect: (targets, user) => ({ type: 'spell', spell: { type: 'forced_target', positive: false, target: user }, targets })
                    }
                ],
                passiveSkills: [
                    {
                        code: 'TEST_02_P1',
                        name: 'Regeneration',
                        description: 'Recover 1 HP at start of turn'
                    }
                ]
            },
            'TEST_03': {
                code: 'TEST_03',
                name: 'Shadow',
                maxHP: 4,
                maxMP: 6,
                maxShield: 4,
                valueTag: 'order',
                groupTags: ['assassin'],
                description: 'High damage dealer',
                activeSkills: [
                    {
                        code: 'TEST_03_01',
                        name: 'Backstab',
                        phase: 'execution',
                        cooldown: 1,
                        mpCost: 0,
                        targetCount: 1,
                        targetType: 'enemy',
                        description: 'Deal 3 physical damage',
                        effect: (targets, user) => ({ type: 'physical', damage: 3, targets })
                    },
                    {
                        code: 'TEST_03_02',
                        name: 'Poison Dart',
                        phase: 'execution',
                        cooldown: 3,
                        mpCost: 1,
                        targetCount: 1,
                        targetType: 'enemy',
                        description: 'Apply poison (2 damage over 2 turns)',
                        effect: (targets, user) => ({ type: 'spell', spell: { type: 'poison', positive: false, damage: 2, duration: 2 }, targets })
                    },
                    {
                        code: 'TEST_03_03',
                        name: 'Vanish',
                        phase: 'pre-execution',
                        cooldown: 3,
                        mpCost: 1,
                        targetCount: 0,
                        targetType: 'self',
                        description: 'Evade next attack',
                        effect: (targets, user) => ({ type: 'spell', spell: { type: 'evade_next', positive: true }, targets: [user] })
                    }
                ],
                passiveSkills: [
                    {
                        code: 'TEST_03_P1',
                        name: 'Critical Strike',
                        description: '20% chance to deal double damage'
                    }
                ]
            }
        };
        
        // Game State
        let gameState = {
            players: [],
            currentTurn: null,
            currentPhase: null,
            rpsChoices: {},
            combatLog: [],
            selectedCharacter: null,
            selectedPassive: null,
            selectedFaction: null,
            gameLength: 5
        };
        
        // Initialize Setup Screen
        function initSetup() {
            const grid = document.getElementById('characterGrid');
            grid.innerHTML = '';
            
            Object.values(CHARACTERS).forEach(char => {
                const card = document.createElement('div');
                card.className = 'character-card';
                card.innerHTML = `
                    <h3>${char.name} (${char.code})</h3>
                    <div class="stat-line">HP: ${char.maxHP} | MP: ${char.maxMP} | Shield: ${char.maxShield}</div>
                    <div class="stat-line">Value: ${char.valueTag} | Groups: ${char.groupTags.join(', ')}</div>
                    <div style="margin-top: 10px; font-size: 11px; color: #888;">${char.description}</div>
                    <div style="margin-top: 10px;">
                        <div style="font-size: 11px; color: #4a9eff; margin-bottom: 5px;">Active Skills:</div>
                        ${char.activeSkills.map(s => `<div class="skill-item">${s.name} (CD:${s.cooldown}, MP:${s.mpCost})</div>`).join('')}
                    </div>
                `;
                card.onclick = () => selectCharacter(char.code);
                grid.appendChild(card);
            });
            
            // Faction buttons
            document.querySelectorAll('.faction-btn').forEach(btn => {
                btn.onclick = () => selectFaction(btn.dataset.faction);
            });
            
            document.getElementById('startBtn').onclick = startGame;
        }
        
        function selectCharacter(code) {
            gameState.selectedCharacter = code;
            document.querySelectorAll('.character-card').forEach(card => {
                card.classList.remove('selected');
            });
            event.target.closest('.character-card').classList.add('selected');
            
            // Show passive selection
            const char = CHARACTERS[code];
            const passiveDiv = document.getElementById('passiveSelect');
            const optionsDiv = document.getElementById('passiveOptions');
            passiveDiv.classList.remove('hidden');
            optionsDiv.innerHTML = '';
            
            char.passiveSkills.forEach((passive, idx) => {
                const option = document.createElement('div');
                option.className = 'passive-option';
                option.innerHTML = `<strong>${passive.name}</strong><br>${passive.description}`;
                option.onclick = () => selectPassive(idx);
                optionsDiv.appendChild(option);
            });
            
            updateStartButton();
        }
        
        function selectPassive(idx) {
            gameState.selectedPassive = idx;
            document.querySelectorAll('.passive-option').forEach((opt, i) => {
                opt.classList.toggle('selected', i === idx);
            });
            updateStartButton();
        }
        
        function selectFaction(faction) {
            gameState.selectedFaction = parseInt(faction);
            document.querySelectorAll('.faction-btn').forEach(btn => {
                btn.classList.toggle('selected', btn.dataset.faction === faction);
            });
            updateStartButton();
        }
        
        function updateStartButton() {
            const btn = document.getElementById('startBtn');
            btn.disabled = !(gameState.selectedCharacter && gameState.selectedPassive !== null && gameState.selectedFaction);
        }
        
        function startGame() {
            // Create players
            const playerChar = CHARACTERS[gameState.selectedCharacter];
            const otherChars = Object.values(CHARACTERS).filter(c => c.code !== gameState.selectedCharacter);
            
            // Shuffle and pick 3 AI characters
            const aiChars = otherChars.sort(() => Math.random() - 0.5).slice(0, 3);
            
            // Create player
            gameState.players = [
                createPlayer(playerChar, true, gameState.selectedFaction, gameState.selectedPassive)
            ];
            
            // Create AI players (distribute factions)
            const factions = [1, 1, 2, 2].filter(f => f !== gameState.selectedFaction);
            aiChars.forEach((char, idx) => {
                const faction = idx < factions.length ? factions[idx] : (Math.random() > 0.5 ? 1 : 2);
                const passiveIdx = Math.floor(Math.random() * char.passiveSkills.length);
                gameState.players.push(createPlayer(char, false, faction, passiveIdx));
            });
            
            // Switch to game screen
            document.getElementById('setupScreen').style.display = 'none';
            document.getElementById('gameScreen').style.display = 'flex';
            
            renderGame();
            addLog('Game started!', 'system');
            startRPSRound();
        }
        
        function createPlayer(character, isPlayer, faction, passiveIdx) {
            return {
                id: Math.random().toString(36).substr(2, 9),
                character: character,
                isPlayer: isPlayer,
                faction: faction,
                hp: character.maxHP,
                mp: character.maxMP,
                shield: character.maxShield,
                cards: [],
                spells: [],
                cooldowns: {},
                reserves: {},
                passiveSkill: character.passiveSkills[passiveIdx],
                alive: true
            };
        }
        
        function renderGame() {
            renderOpponents();
            renderPlayer();
        }
        
        function renderOpponents() {
            const grid = document.getElementById('opponentsGrid');
            grid.innerHTML = '';
            
            const opponents = gameState.players.filter(p => !p.isPlayer);
            opponents.forEach(player => {
                grid.appendChild(createCharPanel(player));
            });
        }
        
        function renderPlayer() {
            const info = document.getElementById('playerInfo');
            const player = gameState.players.find(p => p.isPlayer);
            if (!player) return;
            
            info.innerHTML = '';
            info.appendChild(createCharPanel(player));
            renderPlayerSkills();
        }
        
        function createCharPanel(player) {
            const panel = document.createElement('div');
            panel.className = 'char-panel';
            if (gameState.currentTurn?.id === player.id) {
                panel.classList.add('active-turn');
            }
            if (!player.alive) {
                panel.classList.add('dead');
            }
            
            const hpPercent = (player.hp / player.character.maxHP) * 100;
            const mpPercent = (player.mp / player.character.maxMP) * 100;
            const shieldPercent = (player.shield / player.character.maxShield) * 100;
            
            panel.innerHTML = `
                <div class="char-header">
                    <div class="char-name">${player.character.name} ${player.isPlayer ? '(YOU)' : ''}</div>
                    <div class="faction-badge">Faction ${player.faction}</div>
                </div>
                <div class="stat-bars">
                    <div class="stat-bar">
                        <div class="stat-bar-label">HP</div>
                        <div class="stat-bar-container">
                            <div class="stat-bar-fill hp" style="width: ${hpPercent}%"></div>
                            <div class="stat-bar-text">${player.hp} / ${player.character.maxHP}</div>
                        </div>
                    </div>
                    <div class="stat-bar">
                        <div class="stat-bar-label">MP</div>
                        <div class="stat-bar-container">
                            <div class="stat-bar-fill mp" style="width: ${mpPercent}%"></div>
                            <div class="stat-bar-text">${player.mp.toFixed(1)} / ${player.character.maxMP}</div>
                        </div>
                    </div>
                    <div class="stat-bar">
                        <div class="stat-bar-label">Shield</div>
                        <div class="stat-bar-container">
                            <div class="stat-bar-fill shield" style="width: ${shieldPercent}%"></div>
                            <div class="stat-bar-text">${player.shield} / ${player.character.maxShield}</div>
                        </div>
                    </div>
                </div>
                <div class="char-details">
                    <div class="detail-row">
                        <span style="color: #888;">Passive:</span>
                        <span title="${player.passiveSkill.description}">${player.passiveSkill.name}</span>
                    </div>
                </div>
                ${player.cards.length > 0 ? `
                    <div class="cards-row">
                        <strong>Cards:</strong> ${player.cards.map(c => `<span class="card-chip">${c.toUpperCase()}</span>`).join('')}
                    </div>
                ` : ''}
                ${player.spells.length > 0 ? `
                    <div class="spells-row">
                        <strong>Spells:</strong> ${player.spells.map(s => `<span class="spell-chip" title="${s.type}">${s.type}</span>`).join('')}
                    </div>
                ` : ''}
                ${player.isPlayer ? `
                    <div style="margin-top: 10px; padding: 8px; background: #1a1a1a; font-size: 11px;">
                        ${player.character.activeSkills.map(skill => {
                            const cd = player.cooldowns[skill.code] || 0;
                            const reserves = player.reserves[skill.code] ?? gameState.gameLength;
                            return `
                                <div style="display: flex; justify-content: space-between; margin: 3px 0; padding: 3px; background: #252525;">
                                    <span>${skill.name}</span>
                                    <span style="color: ${cd === 0 ? '#51cf66' : '#ff6b6b'};">CD: ${cd} | Uses: ${reserves}</span>
                                </div>
                            `;
                        }).join('')}
                    </div>
                ` : ''}
            `;
            
            return panel;
        }
        
        function renderPlayerSkills() {
            const player = gameState.players.find(p => p.isPlayer);
            if (!player || !gameState.currentTurn || gameState.currentTurn.id !== player.id) {
                document.getElementById('skillsGrid').innerHTML = '<p style="text-align: center; color: #888;">Waiting for your turn...</p>';
                return;
            }
            
            const phase = gameState.currentPhase;
            const availableSkills = player.character.activeSkills.filter(skill => {
                if (skill.phase !== phase) return false;
                const cd = player.cooldowns[skill.code] || 0;
                const reserves = player.reserves[skill.code] ?? gameState.gameLength;
                return cd === 0 && reserves > 0 && player.mp >= skill.mpCost;
            });
            
            const grid = document.getElementById('skillsGrid');
            grid.innerHTML = '';
            
            // Skip button
            const skipBtn = document.createElement('div');
            skipBtn.className = 'skill-card';
            skipBtn.innerHTML = `
                <div class="skill-card-name">SKIP PHASE</div>
                <div class="skill-card-stats">Continue to next phase</div>
            `;
            skipBtn.onclick = () => continuePhase();
            grid.appendChild(skipBtn);
            
            // Add all skills
            player.character.activeSkills.forEach(skill => {
                const cd = player.cooldowns[skill.code] || 0;
                const reserves = player.reserves[skill.code] ?? gameState.gameLength;
                const canUse = availableSkills.includes(skill);
                
                const card = document.createElement('div');
                card.className = 'skill-card' + (canUse ? '' : ' disabled');
                card.innerHTML = `
                    <div class="skill-card-name">${skill.name}</div>
                    <div class="skill-card-stats">
                        <div class="skill-card-stat">Phase: ${skill.phase}</div>
                        <div class="skill-card-stat">MP: ${skill.mpCost}</div>
                        <div class="skill-card-stat">CD: ${cd}</div>
                        <div class="skill-card-stat">Uses: ${reserves}</div>
                    </div>
                    <div class="tooltip">
                        ${skill.description}<br>
                        <strong>Cooldown:</strong> ${skill.cooldown}<br>
                        <strong>MP Cost:</strong> ${skill.mpCost}
                    </div>
                `;
                
                if (canUse) {
                    card.onclick = () => useSkill(skill);
                }
                
                grid.appendChild(card);
            });
        }
        
        function startRPSRound() {
            const alivePlayers = gameState.players.filter(p => p.alive);
            if (checkVictory()) return;
            
            gameState.rpsChoices = {};
            gameState.rpsActive = alivePlayers.map(p => p.id);
            
            addLog('=== RPS Round Started ===', 'rps');
            
            // ALL players (including AI) make choices simultaneously but hidden
            alivePlayers.forEach(player => {
                if (!player.isPlayer) {
                    const choices = ['rock', 'paper', 'scissors'];
                    const weights = [Math.random(), Math.random(), Math.random()];
                    const maxWeight = Math.max(...weights);
                    const choiceIndex = weights.indexOf(maxWeight);
                    gameState.rpsChoices[player.id] = choices[choiceIndex];
                }
            });
            
            // Show modal for player
            const modal = document.getElementById('rpsModal');
            modal.classList.remove('hidden');
            document.getElementById('rpsWaiting').classList.add('hidden');
            document.getElementById('rpsResults').classList.add('hidden');
            
            document.querySelectorAll('.rps-btn').forEach(btn => {
                btn.onclick = () => playerRPSChoice(btn.dataset.choice);
            });
        }
        
        function playerRPSChoice(choice) {
            const player = gameState.players.find(p => p.isPlayer && p.alive);
            gameState.rpsChoices[player.id] = choice;
            
            // Disable buttons
            document.querySelectorAll('.rps-btn').forEach(btn => {
                btn.disabled = true;
                btn.style.opacity = '0.5';
            });
            
            addLog(`You chose ${choice}`, 'rps');
            
            // Now reveal all choices
            setTimeout(() => {
                displayRPSResults();
                setTimeout(() => resolveRPS(), 2000);
            }, 500);
        }
        
        function displayRPSResults() {
            const resultsDiv = document.getElementById('rpsResults');
            resultsDiv.classList.remove('hidden');
            resultsDiv.innerHTML = '<h3 style="margin-bottom: 10px; color: #4a9eff;">Round Results:</h3>';
            
            gameState.players.filter(p => p.alive).forEach(player => {
                const choice = gameState.rpsChoices[player.id];
                const isActive = gameState.rpsActive.includes(player.id);
                const item = document.createElement('div');
                item.className = 'rps-result-item' + (isActive ? '' : ' eliminated');
                item.innerHTML = `
                    <span>${player.character.name}</span>
                    <span style="font-weight: bold;">${choice ? choice.toUpperCase() : '???'}</span>
                `;
                resultsDiv.appendChild(item);
            });
        }
        
        function resolveRPS() {
            let activeIds = [...gameState.rpsActive];
            let iterations = 0;
            const maxIterations = 20;
            
            while (activeIds.length > 1 && iterations < maxIterations) {
                iterations++;
                
                const activeChoices = activeIds.map(id => gameState.rpsChoices[id]);
                const uniqueChoices = [...new Set(activeChoices)];
                
                if (uniqueChoices.length === 1 || uniqueChoices.length === 3) {
                    addLog('Tie! Re-throwing...', 'rps');
                    
                    // Re-choose for everyone
                    activeIds.forEach(playerId => {
                        const choices = ['rock', 'paper', 'scissors'];
                        const weights = [Math.random(), Math.random(), Math.random()];
                        const maxWeight = Math.max(...weights);
                        const choiceIndex = weights.indexOf(maxWeight);
                        gameState.rpsChoices[playerId] = choices[choiceIndex];
                    });
                    
                    displayRPSResults();
                    continue;
                }
                
                // Two choices - eliminate losers
                const winners = determineRPSWinners(activeIds);
                addLog(`${winners.map(id => gameState.players.find(p => p.id === id).character.name).join(', ')} advance`, 'rps');
                
                gameState.rpsActive = winners;
                activeIds = winners;
                displayRPSResults();
                
                if (activeIds.length === 1) break;
                
                // Re-choose for winners
                activeIds.forEach(playerId => {
                    const choices = ['rock', 'paper', 'scissors'];
                    const weights = [Math.random(), Math.random(), Math.random()];
                    const maxWeight = Math.max(...weights);
                    const choiceIndex = weights.indexOf(maxWeight);
                    gameState.rpsChoices[playerId] = choices[choiceIndex];
                });
                
                displayRPSResults();
            }
            
            if (iterations >= maxIterations) {
                const winnerId = activeIds[Math.floor(Math.random() * activeIds.length)];
                activeIds = [winnerId];
                addLog('Tie limit reached, random winner selected', 'rps');
            }
            
            // Winner
            const winnerId = activeIds[0];
            const winner = gameState.players.find(p => p.id === winnerId);
            const winnerChoice = gameState.rpsChoices[winnerId];
            winner.cards.push(winnerChoice);
            addLog(`${winner.character.name} wins! Card: ${winnerChoice}`, 'rps');
            
            setTimeout(() => {
                document.getElementById('rpsModal').classList.add('hidden');
                // Re-enable buttons for next round
                document.querySelectorAll('.rps-btn').forEach(btn => {
                    btn.disabled = false;
                    btn.style.opacity = '1';
                });
                renderGame();
                startTurn(winner);
            }, 2000);
        }
        
        function determineRPSWinners(activeIds) {
            const choiceMap = {};
            activeIds.forEach(id => {
                const choice = gameState.rpsChoices[id];
                if (!choiceMap[choice]) choiceMap[choice] = [];
                choiceMap[choice].push(id);
            });
            
            const choices = Object.keys(choiceMap);
            if (choices.length !== 2) return activeIds;
            
            const [c1, c2] = choices;
            const winningChoice = getWinningChoice(c1, c2);
            return choiceMap[winningChoice];
        }
        
        function getWinningChoice(c1, c2) {
            if (c1 === 'rock' && c2 === 'scissors') return 'rock';
            if (c1 === 'scissors' && c2 === 'rock') return 'rock';
            if (c1 === 'paper' && c2 === 'rock') return 'paper';
            if (c1 === 'rock' && c2 === 'paper') return 'paper';
            if (c1 === 'scissors' && c2 === 'paper') return 'scissors';
            if (c1 === 'paper' && c2 === 'scissors') return 'scissors';
            return c1;
        }
        
        async function startTurn(player) {
            gameState.currentTurn = player;
            addLog(`=== ${player.character.name}'s Turn ===`, 'system');
            renderGame();
            
            await executePhases(player);
        }
        
        async function executePhases(player) {
            const phases = ['initialization', 'pre-execution', 'execution', 'post-execution', 'finalization'];
            
            for (const phase of phases) {
                gameState.currentPhase = phase;
                await executePhase(player, phase);
            }
            
            addLog(`Turn ended`, 'system');
            gameState.currentTurn = null;
            gameState.currentPhase = null;
            renderGame();
            
            setTimeout(() => startRPSRound(), 1000);
        }
        
        async function executePhase(player, phase) {
            addLog(`Phase: ${phase}`, 'system');
            document.getElementById('phaseIndicator').textContent = phase.toUpperCase();
            
            if (phase === 'pre-execution') {
                player.mp = Math.min(player.mp + 0.5, player.character.maxMP);
                addLog(`${player.character.name} gains 0.5 MP`, 'system');
                renderGame();
            }
            
            if (phase !== 'initialization' && phase !== 'finalization') {
                await useSkillInPhase(player, phase);
            }
            
            if (phase === 'finalization') {
                Object.keys(player.cooldowns).forEach(skillCode => {
                    if (player.cooldowns[skillCode] > 0) {
                        player.cooldowns[skillCode]--;
                    }
                });
                renderGame();
            }
        }
        
        function useSkillInPhase(player, phase) {
            const availableSkills = player.character.activeSkills.filter(skill => {
                if (skill.phase !== phase) return false;
                const cd = player.cooldowns[skill.code] || 0;
                const reserves = player.reserves[skill.code] ?? gameState.gameLength;
                return cd === 0 && reserves > 0 && player.mp >= skill.mpCost;
            });
            
            if (availableSkills.length === 0) {
                addLog(`No skills available in ${phase}`, 'system');
                return Promise.resolve();
            }
            
            if (player.isPlayer) {
                return playerChooseSkill(player, availableSkills);
            } else {
                return aiChooseSkill(player, availableSkills);
            }
        }
        
        function playerChooseSkill(player, skills) {
            return new Promise((resolve) => {
                gameState.phaseResolve = resolve;
                renderPlayerSkills();
            });
        }
        
        function continuePhase() {
            if (gameState.phaseResolve) {
                gameState.phaseResolve();
                gameState.phaseResolve = null;
            }
        }
        
        async function aiChooseSkill(player, skills) {
            const isAttack = Math.random() < 0.7;
            const filtered = skills.filter(s => {
                const isAttackSkill = s.targetType === 'enemy';
                return isAttack ? isAttackSkill : !isAttackSkill;
            });
            
            const chosen = filtered.length > 0 ? 
                filtered[Math.floor(Math.random() * filtered.length)] :
                skills[Math.floor(Math.random() * skills.length)];
            
            await useSkill(chosen, player);
        }
        
        async function useSkill(skill, user) {
            if (!user) user = gameState.players.find(p => p.isPlayer);
            
            addLog(`${user.character.name} uses ${skill.name}`, 'system');
            
            user.mp -= skill.mpCost;
            user.cooldowns[skill.code] = skill.cooldown;
            
            if (!user.reserves[skill.code]) user.reserves[skill.code] = gameState.gameLength;
            user.reserves[skill.code]--;
            
            Object.keys(user.cooldowns).forEach(code => {
                if (code !== skill.code && user.cooldowns[code] > 0) {
                    user.cooldowns[code]--;
                }
            });
            
            renderGame();
            
            let targets = [];
            if (skill.targetCount === 0) {
                targets = [user];
            } else if (skill.targetCount === 'all') {
                targets = gameState.players.filter(p => p.alive && p.id !== user.id);
            } else {
                targets = await selectTargets(user, skill);
            }
            
            const result = skill.effect(targets, user);
            await applyEffect(result, user);
            
            if (gameState.phaseResolve) {
                gameState.phaseResolve();
                gameState.phaseResolve = null;
            }
        }
        
        function selectTargets(player, skill) {
            return new Promise((resolve) => {
                if (!player.isPlayer) {
                    const eligible = gameState.players.filter(p => {
                        if (!p.alive) return false;
                        if (skill.targetType === 'enemy') return p.faction !== player.faction;
                        if (skill.targetType === 'ally') return p.faction === player.faction;
                        return true;
                    });
                    
                    const selected = [];
                    for (let i = 0; i < Math.min(skill.targetCount, eligible.length); i++) {
                        const target = eligible[Math.floor(Math.random() * eligible.length)];
                        selected.push(target);
                    }
                    resolve(selected);
                    return;
                }
                
                const modal = document.getElementById('targetModal');
                const grid = document.getElementById('targetGrid');
                modal.classList.remove('hidden');
                grid.innerHTML = '';
                
                const selectedTargets = [];
                
                const eligible = gameState.players.filter(p => {
                    if (!p.alive) return false;
                    if (skill.targetType === 'enemy') return p.faction !== player.faction;
                    if (skill.targetType === 'ally') return p.faction === player.faction;
                    if (skill.targetType === 'self') return p.id === player.id;
                    return true;
                });
                
                eligible.forEach(target => {
                    const card = document.createElement('div');
                    card.className = 'target-card';
                    card.innerHTML = `
                        <div style="font-weight: bold; margin-bottom: 5px;">${target.character.name}</div>
                        <div style="font-size: 11px;">HP: ${target.hp}/${target.character.maxHP}</div>
                        <div style="font-size: 11px;">Shield: ${target.shield}/${target.character.maxShield}</div>
                    `;
                    card.onclick = () => {
                        if (selectedTargets.includes(target)) {
                            selectedTargets.splice(selectedTargets.indexOf(target), 1);
                            card.classList.remove('selected');
                        } else if (selectedTargets.length < skill.targetCount) {
                            selectedTargets.push(target);
                            card.classList.add('selected');
                        }
                    };
                    grid.appendChild(card);
                });
                
                document.getElementById('confirmTargetBtn').onclick = () => {
                    modal.classList.add('hidden');
                    resolve(selectedTargets);
                };
            });
        }
        
        async function applyEffect(effect, user) {
            if (effect.type === 'physical' || effect.type === 'magical') {
                for (const target of effect.targets) {
                    let damage = effect.damage;
                    
                    const evade = target.spells.find(s => s.type === 'evade_next');
                    if (evade) {
                        addLog(`${target.character.name} evaded!`, 'system');
                        target.spells = target.spells.filter(s => s !== evade);
                        continue;
                    }
                    
                    if (effect.type === 'physical') {
                        const shieldDamage = Math.min(target.shield, damage);
                        target.shield -= shieldDamage;
                        damage -= shieldDamage;
                        
                        if (damage > 0) {
                            target.hp -= damage;
                            addLog(`${target.character.name} takes ${damage} physical (${shieldDamage} blocked)`, 'damage');
                        } else {
                            addLog(`${target.character.name}'s shield blocks ${shieldDamage}`, 'system');
                        }
                    } else {
                        target.hp -= damage;
                        addLog(`${target.character.name} takes ${damage} magical`, 'damage');
                    }
                    
                    if (target.hp <= 0) {
                        target.hp = 0;
                        target.alive = false;
                        addLog(`${target.character.name} defeated!`, 'damage');
                    }
                    
                    if (user.passiveSkill.code === 'YRYR_00_P1') {
                        target.mp = Math.max(0, target.mp - 1);
                        addLog(`${target.character.name} loses 1 MP`, 'system');
                    }
                }
            } else if (effect.type === 'heal') {
                for (const target of effect.targets) {
                    const healed = Math.min(effect.amount, target.character.maxHP - target.hp);
                    target.hp += healed;
                    addLog(`${target.character.name} recovers ${healed} HP`, 'heal');
                }
            } else if (effect.type === 'shield') {
                for (const target of effect.targets) {
                    const added = Math.min(effect.amount, target.character.maxShield - target.shield);
                    target.shield += added;
                    addLog(`${target.character.name} gains ${added} shield`, 'system');
                }
            } else if (effect.type === 'spell') {
                for (const target of effect.targets) {
                    target.spells.push(effect.spell);
                    addLog(`${target.character.name} receives: ${effect.spell.type}`, 'spell');
                }
            }
            
            renderGame();
        }
        
        function checkVictory() {
            const factions = {};
            gameState.players.filter(p => p.alive).forEach(p => {
                if (!factions[p.faction]) factions[p.faction] = [];
                factions[p.faction].push(p);
            });
            
            const aliveFactions = Object.keys(factions);
            if (aliveFactions.length === 1) {
                const winner = aliveFactions[0];
                addLog(`=== FACTION ${winner} WINS! ===`, 'system');
                
                const playerWon = factions[winner].some(p => p.isPlayer);
                if (playerWon) {
                    addLog('YOU WIN!', 'heal');
                } else {
                    addLog('YOU LOSE!', 'damage');
                }
                
                return true;
            }
            return false;
        }
        
        function addLog(message, type = 'system') {
            const log = document.getElementById('combatLog');
            const entry = document.createElement('div');
            entry.className = `log-entry log-${type}`;
            entry.textContent = message;
            log.appendChild(entry);
            log.scrollTop = log.scrollHeight;
        }
        
        initSetup();
    </script>
</body>
</html>